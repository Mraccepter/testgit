package 今日头条;
/*
 * 题意：给定两个数列 A 和 B 以及 q 组查询 (x, y)，每次求满足 A[i] >= x 且 B[i] >= y 这样的 i 的数量。

题解：暴力的 O(n * q) 的做法可以通过 30% 的数据。
考虑把原先所有 (A[i], B[i]) 整数对按照 A 排序，
所有查询按照 x 排序。随后从小到大扫描所有查询 (x[i], y[i])，
维护一个指针 k 指向 AB 对中满足 A[k] >= x[i] 的位置。
对于当前的这次查询，要求的就是所有大于 k 的位置中，
满足 B[k] >= y[i] 的数量。
因此我们维护一个高效支持 insert / delete / lower_bound 的
数据结构来维护当前合法的 B 的值即可，
满足条件的包括树状数组，平衡树等，复杂度都在 log 级别。（
如果将 k 从后往前维护，可以省去 delete 操作）

总的复杂度为 O(n + qlogn)。
 * */
public class Main1 {

}
